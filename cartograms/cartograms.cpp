// cartograms.cpp
// HASHIMOTO, Yasuhiro (E-mail: hy @ sys.t.u-tokyo.ac.jp)

/* Based on the code written by Prof. Mark Newman.
 * See http://www.umich.edu/~mejn/
 */

#ifdef _MSC_VER
#include <array>
#else
#include <tr1/array>
#endif
#include <fftw3.h>
#include <boost/format.hpp>
#include "cartograms.h"
#include "../shared/thread.h"
#include "../shared/math.h"

namespace hashimoto_ut {

  using std::vector;
  using std::wstring;
  using std::tr1::array;

  namespace {
    /* The parameter OFFSET specifies a small amount to be added the density in
     * every grid square, as a Fraction of the mean density on the whole
     * lattice. This prevents negative densities from being generated by
     * numerical errors in the FFTs which can cause problems for the
     * integrator. If the program is giving weird behavior, particularly at
     * the beginning of a calculation, try increasing this quantity by a factor
     * of 10.
     */
    double const OFFSET = 0.005;
    double const INITH = 0.001;       // Initial size of a time-step
    double const TARGETERROR = 0.01;  // Desired accuracy per step in pixels
    double const MAXRATIO = 4.0;      // Max ratio to increase step size by
    double const EXPECTEDTIME = 1e+8; // Guess as to the time it will take, used to estimate completion

  } // The end of the anonymous namespace


  class Cartograms {
  public:
    ////////////////////////////////////////////////////////////////////////////////
    Cartograms(vector<double> const& density, int xsize, int ysize, double blur)
         : rho_(density), xsize_(xsize), ysize_(ysize), blur_(blur) {}


    ////////////////////////////////////////////////////////////////////////////////
    /* Function to calculate the population density at arbitrary time by back-
     * transforming and put the result in a particular rhot_[] snapshot array.
     * Calculates unnormalized densities, since FFTW gives unnormalized back-
     * transforms, but this doesn't matter because the cartograms method is
     * insensitive to variation in the density by a multiplicative constant */

    void calc_density_grid(fftw_plan const& plan, double t) {

      /* Calculate the expky array, to save time in the next part */
      vector<double> expky(ysize_); // Arrayneeded for the Gaussian convolution

      for (int iy=0; iy<ysize_; ++iy) {
        double const ky = M_PI*iy/ysize_;
        expky[iy] = exp(-ky*ky*t);
      }

      /* Multiply the FT of the density by the appropriate factors */
      for (int ix=0; ix<xsize_; ++ix) {
        double const kx = M_PI*ix/xsize_;
        double const expkx = exp(-kx*kx*t);
        for (int iy=0; iy<ysize_; ++iy) {
          fftexpt_[ix*ysize_+iy] = expkx*expky[iy]*fftrho_[ix*ysize_+iy];
        }
      }

      /* Perform the back-transform */
      fftw_execute(plan);
    }


    ////////////////////////////////////////////////////////////////////////////////
    /* Function to calculate the velocity at all integer grid points for a
     * specified snapshot */

    void calc_velocity_grid(vector<vector<Vector2<double> > >& vt,
                            vector<double> const& rhot) {

      { /* Do the top border */
        double r11 = rhot[0];
        for (int ix=1; ix<xsize_; ++ix) {
          double const r01 = r11;
          r11 = rhot[ix*ysize_];
          vt[ix][0].set(-2*(r11-r01)/(r11+r01), 0.0);
        }
      }

      { /* Do the bottom border */
        double r10 = rhot[ysize_-1];
        for (int ix=1; ix<xsize_; ++ix) {
          double const r00 = r10;
          r10 = rhot[ix*ysize_+ysize_-1];
          vt[ix][ysize_].set(-2*(r10-r00)/(r10+r00), 0.0);
        }
      }

      { /* Left edge */
        double r11 = rhot[0];
        for (int iy=1; iy<ysize_; ++iy) {
          double const r10 = r11;
          r11 = rhot[iy];
          vt[0][iy].set(0.0, -2*(r11-r10)/(r11+r10));
        }
      }

      { /* Right edge */
        double r01 = rhot[(xsize_-1)*ysize_];
        for (int iy=1; iy<ysize_; ++iy) {
          double const r00 = r01;
          r01 = rhot[(xsize_-1)*ysize_+iy];
          vt[xsize_][iy].set(0.0, -2*(r01-r00)/(r01+r00));
        }
      }

      /* Now do all the points in the middle */

      for (int ix=1; ix<xsize_; ++ix) {
        double r01 = rhot[(ix-1)*ysize_];
        double r11 = rhot[ix*ysize_];
        for (int iy=1; iy<ysize_; ++iy) {
          double const r00 = r01;
          double const r10 = r11;
          r01 = rhot[(ix-1)*ysize_+iy];
          r11 = rhot[ix*ysize_+iy];
          double const mid = r10+r00+r11+r01;
          vt[ix][iy].set(-2*(r10-r00+r11-r01)/mid,
                         -2*(r01-r00+r11-r10)/mid);
        }
      }
    }


    ////////////////////////////////////////////////////////////////////////////////
    /* Function to calculate the velocity at an arbitrary point from the grid
     * velocities for a specified snapshot by interpolating between grid
     * points.  If the requested point is outside the boundaries, we
     * extrapolate (ensures smooth flow back in if we get outside by mistake,
     * although we should never actually do this because function twosteps()
     * contains code to prevent it) */

    Vector2<double> calc_velocity(Vector2<double> const& r,
                                  vector<vector<Vector2<double> > > const& vt) {

      /* Deal with the boundary conditions */

      int ix = int(r.x);
      if (ix<0) ix = 0;
      else if (ix>=xsize_) ix = xsize_-1;

      int iy = int(r.y);
      if (iy<0) iy = 0;
      else if (iy>=ysize_) iy = ysize_-1;

      /* Calculate the weights for the bilinear interpolation */

      double const dx = r.x-ix;
      double const dy = r.y-iy;

      double const dx1m = 1.0-dx;
      double const dy1m = 1.0-dy;

      double const w11 = dx1m*dy1m;
      double const w21 = dx*dy1m;
      double const w12 = dx1m*dy;
      double const w22 = dx*dy;

      /* Perform the interpolation for x and y components of velocity */
      return Vector2<double>(
        w11*vt[ix][iy].x+w21*vt[ix+1][iy].x
        +w12*vt[ix][iy+1].x+w22*vt[ix+1][iy+1].x,
        w11*vt[ix][iy].y+w21*vt[ix+1][iy].y
        +w12*vt[ix][iy+1].y+w22*vt[ix+1][iy+1].y);
    }


    ////////////////////////////////////////////////////////////////////////////////
    /* Function to integrate 2h time into the future two different ways using
     * four-order Runge-Kutta and compare the differences for the purposes of
     * the adaptive step size.  Parameters are:
     *   point = array of points
     *   t = current time, i.e., start time of these two steps
     *   h = delta t
     *   s = snapshot index of the initial time
     *   *errorp = the maximum integration error found for any polygon vertex for
     *             the complete two-step process
     *   *spp = the snapshot index for the final function evaluation
     *
     * Return maximum distance moved by any point.
     */

    double twosteps(vector<Vector2<double> >& point,
                    double t, double h, int s,
                    double *errorp, int *spp) {

      double esqmax = 0.0;
      double drsqmax = 0.0;

      int const s0 = s;
      int const s1 = (s+1)%5;
      int const s2 = (s+2)%5;
      int const s3 = (s+3)%5;
      int const s4 = (s+4)%5;

      /* Calculate the density field for the four new time slices */

      calc_density_grid(rhotplan_[s1], t+0.5*h);
      calc_density_grid(rhotplan_[s2], t+1.0*h);
      calc_density_grid(rhotplan_[s3], t+1.5*h);
      calc_density_grid(rhotplan_[s4], t+2.0*h);

      /* Calculate the resulting velocity grids */

      calc_velocity_grid(vt_[s1], rhot_[s1]);
      calc_velocity_grid(vt_[s2], rhot_[s2]);
      calc_velocity_grid(vt_[s3], rhot_[s3]);
      calc_velocity_grid(vt_[s4], rhot_[s4]);

      /* Do all three RK steps for each point in turn */

      for (size_t p=0; p<point.size(); ++p) {

        Vector2<double> const r1 = point[p];

        /* Do the big combined (2h) RK step */

        Vector2<double> v1 = calc_velocity(r1, vt_[s0]);
        Vector2<double> k1 = 2*h*v1;

        Vector2<double> v2 = calc_velocity(r1+0.5*k1, vt_[s2]);
        Vector2<double> k2 = 2*h*v2;

        Vector2<double> v3 = calc_velocity(r1+0.5*k2, vt_[s2]);
        Vector2<double> k3 = 2*h*v3;

        Vector2<double> v4 = calc_velocity(r1+k3, vt_[s4]);
        Vector2<double> k4 = 2*h*v4;

        Vector2<double> d12 = (k1+k4+2.0*(k2+k3))/6.0;

        /* Do the first small RK step.  No initial call to calc_velocity() is done
         * because it would be the same as the one above, so there's no need
         * to do it again */

        k1 = h*v1;

        v2 = calc_velocity(r1+0.5*k1, vt_[s1]);
        k2 = h*v2;

        v3 = calc_velocity(r1+0.5*k2, vt_[s1]);
        k3 = h*v3;

        v4 = calc_velocity(r1+k3, vt_[s2]);
        k4 = h*v4;

        Vector2<double> const d1 = (k1+k4+2.0*(k2+k3))/6.0;

        /* Do the second small RK step */

        Vector2<double> r2 = r1+d1;

        v1 = calc_velocity(r2, vt_[s2]);
        k1 = h*v1;

        v2 = calc_velocity(r2+0.5*k1, vt_[s3]);
        k2 = h*v2;

        v3 = calc_velocity(r2+0.5*k2, vt_[s3]);
        k3 = h*v3;

        v4 = calc_velocity(r2+k3, vt_[s4]);
        k4 = h*v4;

        Vector2<double> const d2 = (k1+k4+2.0*(k2+k3))/6.0;

        /* Calculate the (squared) error */

        Vector2<double> const e = (d1+d2-d12)/15.0;
        double const esq = e.norm2();
        if (esq>esqmax) esqmax = esq;

        /* Update the position of the vertex using the more accurate (two small
         * steps) result, and deal with the boundary conditions.  This code
         * does 5th-order "local extrapolation" (which just means taking
         * the estimate of the 5th-order term above and adding it to our
         * 4th-order result get a result accurate to the next highest order) */

        Vector2<double> dtotal = d1+d2+e; // Last term is local extrapolation
        double const drsq = dtotal.norm2();
        if (drsq>drsqmax) drsqmax = drsq;

        Vector2<double> r3 = r1+dtotal;

        if (r3.x<0) r3.x = 0;
        else if (r3.x>xsize_) r3.x = xsize_;
        if (r3.y<0) r3.y = 0;
        else if (r3.y>ysize_) r3.y = ysize_;

        point[p] = r3;
      }

      *errorp = sqrt(esqmax);
      *spp = s4;
      return sqrt(drsqmax);
    }


    ////////////////////////////////////////////////////////////////////////////////
    /* Function to estimate the percentage completion */

    int complete(double t) {
      int res = int(100.0*log(t/INITH)/log(EXPECTEDTIME/INITH));
      if (res>100) res = 100;
      return res;
    }


    ////////////////////////////////////////////////////////////////////////////////
    vector<Vector2<double> > calc(Thread* parent, wstring* status) {

      assert(!rho_.empty());
      assert(rho_.size()==xsize_*ysize_);

      wstring status_base = status!=0?(*status):L"";

      size_t const sz = size_t(xsize_*ysize_);

      fftrho_.resize(sz);
      fftexpt_.resize(sz);

      for (int i=0; i<5; ++i) {
        rhot_[i].resize(sz);
        vt_[i].resize(xsize_+1, vector<Vector2<double> >(ysize_+1));

        rhotplan_[i] = fftw_plan_r2r_2d(xsize_, ysize_, &fftexpt_[0], &rhot_[i][0],
                                       FFTW_REDFT01, FFTW_REDFT01, FFTW_MEASURE);
      }

      {
        double mean = 0.0;

        for (size_t i=0; i<sz; ++i) mean += rho_[i];
        mean /= sz;
        mean *= OFFSET;
        for (size_t i=0; i<sz; ++i) rho_[i] += mean;

        fftw_plan plan = fftw_plan_r2r_2d(xsize_, ysize_, &rho_[0], &fftrho_[0],
                                          FFTW_REDFT10, FFTW_REDFT10, FFTW_ESTIMATE);
        fftw_execute(plan);
        fftw_destroy_plan(plan);
      }

      /* Calculate the initial density and velocity for snapshot zero */

      calc_density_grid(rhotplan_[0], 0.0);
      calc_velocity_grid(vt_[0], rhot_[0]);

      point_.resize((xsize_+1)*(ysize_+1));

      for (int x=0, i=0; x<=xsize_; ++x) {
        for (int y=0; y<=ysize_; ++y, ++i) {
          point_[i].set(double(x), double(y));
        }
      }

      /* Now integrate the points in the polygons */

      int s = 0;
      double t = 0.5*blur_*blur_;
      double h = INITH;
      double error;
      int sp;

      while (twosteps(point_, t, h, s, &error, &sp)>0.0) {

        if (parent && parent->cancel_check()) {
          for (int i=0; i<5; ++i) fftw_destroy_plan(rhotplan_[i]);
          return vector<Vector2<double> >();
        }

        t += 2.0*h;
        s = sp;

        /* Adjust the time-step.  Factor of 2 arises because the target for
         * the two-step process is twice the target for an individual step */

        double const desiredratio = pow(2*TARGETERROR/error, 0.2);
        if (desiredratio>MAXRATIO) h *= MAXRATIO;
        else h *= desiredratio;

        if (status)
          *status
            = status_base+(boost::wformat(L": %d%% [err=%.02f]")
                           %complete(t)%error).str();
      }

      for (int i=0; i<5; ++i) fftw_destroy_plan(rhotplan_[i]);
      return point_;
    }


    ////////////////////////////////////////////////////////////////////////////////
    vector<Vector2<double> > const& get(void) const {
      return point_;
    }

  private:
    vector<double> rho_;
    vector<Vector2<double> > point_;
    int xsize_;
    int ysize_;
    double blur_;

    vector<double> fftrho_;  // FT of initial density
    vector<double> fftexpt_; // FT of density at time t
    array<vector<double>, 5> rhot_; // Pop density at time t (five snaps needed)
    array<vector<vector<Vector2<double> > >, 5> vt_; // Velocity at time t
    array<fftw_plan, 5> rhotplan_; // Plan for rho(t) back-transform at time t
  };


  namespace cartograms {

    ////////////////////////////////////////////////////////////////////////////////
    vector<Vector2<double> >
      generate(Thread* parent, wstring* status,
               vector<double> const& density, int xsize, int ysize, double blur) {
        Cartograms c(density, xsize, ysize, blur);
        return c.calc(parent, status);
      }

  }

} // The end of the namespace "hashimoto_ut"
